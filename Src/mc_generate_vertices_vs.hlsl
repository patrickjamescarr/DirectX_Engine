// marching cubes vertex shader

struct gridCell {
    float3 p[8];
    float densityValue[8];
};

cbuffer MatrixBuffer : register(b0)
{
    matrix worldMatrix;
    matrix viewMatrix;
    matrix projectionMatrix;
};

// Buffer to store the cube variables
// x val contains cube scale
// y val contains cube dimentions
cbuffer CubeBuffer : register(b1)
{
    float4 cubeVariables;
};

struct VSInput
{
    float4 position     : POSITION;
    float2 tex          : TEXCOORD;
    uint   nInstanceID  : SV_InstanceID;   // generated by the vertex shader. each slice is an instance
};

struct VSOutput
{
    float4 wsCellCoords[8]      : CELL;
    float3 densityVolCoords[8]  : DENSITY;
};

float4 ApplyMatrices(float4 coord)
{
    float4 outCoord;

    outCoord = mul(coord, worldMatrix);

    return outCoord;
}

VSOutput main(VSInput input)
{
    VSOutput output;

    input.position.w = 1.0f;

    float scale = cubeVariables.x;
    float cubeDims = cubeVariables.y;

    float cubeSize = 1.0f * scale;

    float4 cubeCoord = input.position;
    cubeCoord.z = (float)input.nInstanceID * scale;

    float textureCoordinatesStep = 1.0f / cubeDims;
    float densityLayer = (float)input.nInstanceID * textureCoordinatesStep;


    // calculate the surrounding vertex coordinates
    // front face
    output.wsCellCoords[0] = ApplyMatrices(float4(cubeCoord.x, (cubeCoord.y + cubeSize), cubeCoord.z, cubeCoord.w));                // top left
    output.wsCellCoords[1] = ApplyMatrices(float4((cubeCoord.x + cubeSize), (cubeCoord.y + cubeSize), cubeCoord.z, cubeCoord.w));   // top right
    output.wsCellCoords[2] = ApplyMatrices(float4((cubeCoord.x + cubeSize), cubeCoord.y, cubeCoord.z, cubeCoord.w));                // bottom right
    output.wsCellCoords[3] = ApplyMatrices(float4(cubeCoord.x, cubeCoord.y, cubeCoord.z, cubeCoord.w));                             // bottom left

    // back face
    output.wsCellCoords[4] = ApplyMatrices(float4(cubeCoord.x, (cubeCoord.y + cubeSize), (cubeCoord.z + cubeSize), cubeCoord.w));               // top left
    output.wsCellCoords[5] = ApplyMatrices(float4((cubeCoord.x + cubeSize), (cubeCoord.y + cubeSize), (cubeCoord.z + cubeSize), cubeCoord.w));  // top right
    output.wsCellCoords[6] = ApplyMatrices(float4((cubeCoord.x + cubeSize), cubeCoord.y, (cubeCoord.z + cubeSize), cubeCoord.w));               // bottom right
    output.wsCellCoords[7] = ApplyMatrices(float4(cubeCoord.x, cubeCoord.y, (cubeCoord.z + cubeSize), cubeCoord.w));                            // bottom left

    // calculate the surrounding density values
    // front face
    output.densityVolCoords[0] = float3(input.tex.x, (input.tex.y + textureCoordinatesStep), densityLayer);                             // top left
    output.densityVolCoords[1] = float3((input.tex.x + textureCoordinatesStep), (input.tex.y + textureCoordinatesStep), densityLayer);  // top right
    output.densityVolCoords[2] = float3((input.tex.x + textureCoordinatesStep), input.tex.y, densityLayer);                             // bottom right
    output.densityVolCoords[3] = float3(input.tex.x, input.tex.y, densityLayer);                                                        // bottom left

    // back face
    output.densityVolCoords[4] = float3(input.tex.x, (input.tex.y + textureCoordinatesStep), (densityLayer + textureCoordinatesStep));                              // top left
    output.densityVolCoords[5] = float3((input.tex.x + textureCoordinatesStep), (input.tex.y + textureCoordinatesStep), (densityLayer + textureCoordinatesStep));   // top right
    output.densityVolCoords[6] = float3((input.tex.x + textureCoordinatesStep), input.tex.y, (densityLayer + textureCoordinatesStep));                              // bottom right
    output.densityVolCoords[7] = float3(input.tex.x, input.tex.y, (densityLayer + textureCoordinatesStep));                                                         // bottom left


    return output;
}